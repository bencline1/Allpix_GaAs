/**
 * @file
 * @brief Definition of impact ionization models
 *
 * @copyright Copyright (c) 2021 CERN and the Allpix Squared authors.
 * This software is distributed under the terms of the MIT License, copied verbatim in the file "LICENSE.md".
 * In applying this license, CERN does not waive the privileges and immunities granted to it by virtue of its status as an
 * Intergovernmental Organization or submit itself to any jurisdiction.
 */

#ifndef ALLPIX_IMPACTIONIZATION_MODELS_H
#define ALLPIX_IMPACTIONIZATION_MODELS_H

#include "exceptions.h"

#include "core/utils/unit.h"
#include "objects/SensorCharge.hpp"

namespace allpix {

    /**
     * @ingroup Models
     * @brief Impact ionization models
     */
    class ImpactIonizationModel {
    public:
        /**
         * Default constructor
         */
        ImpactIonizationModel() = default;

        /**
         * Default virtual destructor
         */
        virtual ~ImpactIonizationModel() = default;

        /**
         * Function call operator to obtain mobility value for the given carrier type and electric field magnitude
         * @param type Type of charge carrier (electron or hole)
         * @param efield_mag Magnitude of the electric field
         * @param threshold Threshold electric field for impact ionization
         * @param step Length of the current step
         * @return Gain generated by impact ionization in this step
         */
        virtual double operator()(const CarrierType& type, double efield_mag, double threshold, double step) const = 0;
    };

    /**
     * @ingroup Models
     * @brief No multiplication
     *
     */
    class None : virtual public ImpactIonizationModel {
    public:
        double operator()(const CarrierType&, double, double, double) const override { return 1.; };
    };

    /**
     * @ingroup Models
     * @brief Massey model for impact ionization
     *
     * Formulae 2a for electrons and 2b for holes, temperature dependence equation 3 of
     * https://ieeexplore.ieee.org/document/1677871. Parameter values from text in section III, below formulae.
     */
    class Massey : virtual public ImpactIonizationModel {
    public:
        Massey(double temperature)
            : electron_a_(Units::get(4.43e5, "/cm")),
              electron_b_(Units::get(9.66e5, "V/cm") + Units::get(4.99e2, "V/cm/K") * temperature),
              hole_a_(Units::get(1.13e6, "/cm")),
              hole_b_(Units::get(1.71e6, "V/cm") + Units::get(1.09e3, "V/cm/K") * temperature) {}

        double operator()(const CarrierType& type, double efield_mag, double threshold, double step) const override {
            if(std::fabs(efield_mag) < threshold) {
                return 1.;
            }
            if(type == CarrierType::ELECTRON) {
                return std::exp(step * electron_a_ * std::exp(-1. * electron_b_ / efield_mag));
            } else {
                return std::exp(step * hole_a_ * std::exp(-1. * hole_b_ / efield_mag));
            }
        };

    private:
        double electron_a_;
        double electron_b_;

        double hole_a_;
        double hole_b_;
    };

    /**
     * @ingroup Models
     * @brief van Overstraeten model for impact ionization
     *
     * Comment: in the TCAD manual, T0 for the calculation of gamma is never stated for the van Overstraeten-de Man model. It
     * is given as 300K for the Okuto-Crowell model and is assumed to be also 300K here
     */
    class VanOverstraeten : virtual public ImpactIonizationModel {
    public:
        VanOverstraeten(double temperature)
            : gamma_(std::tanh(Units::get(0.063e6, "eV") / (2. * Units::get(8.6173e-5, "eV/K") * 300.)) /
                     std::tanh(Units::get(0.063e6, "eV") / (2. * Units::get(8.6173e-5, "eV/K") * temperature))),
              e_zero_(Units::get(4.0e5, "V/cm")), electron_a_(Units::get(7.03e5, "/cm")),
              electron_b_(Units::get(1.231e6, "V/cm")), hole_a_low_(Units::get(1.582e6, "/cm")),
              hole_a_high_(Units::get(6.71e5, "/cm")), hole_b_low_(Units::get(2.036e6, "V/cm")),
              hole_b_high_(Units::get(1.693e6, "V/cm")) {}

        double operator()(const CarrierType& type, double efield_mag, double threshold, double step) const override {
            if(std::fabs(efield_mag) < threshold) {
                return 1.;
            }

            if(type == CarrierType::ELECTRON) {
                return std::exp(step * gamma_ * electron_a_ * std::exp(-(gamma_ * electron_b_ / efield_mag)));
            } else {
                auto a = (std::abs(efield_mag) > e_zero_ ? hole_a_high_ : hole_a_low_);
                auto b = (std::abs(efield_mag) > e_zero_ ? hole_b_high_ : hole_b_low_);
                return std::exp(step * gamma_ * a * std::exp(-(gamma_ * b / efield_mag)));
            }
        };

    private:
        double gamma_;
        double e_zero_;

        double electron_a_;
        double electron_b_;

        double hole_a_low_;
        double hole_a_high_;
        double hole_b_low_;
        double hole_b_high_;
    };

    /**
     * @brief Wrapper class and factory for impact ionization models.
     *
     * This class allows to store mobility objects independently of the model chosen and simplifies access to the function
     * call operator. The constructor acts as factory, generating model objects from the model name provided, e.g. from a
     * configuration file.
     */
    class ImpactIonization {
    public:
        /**
         * Default constructor
         */
        ImpactIonization() = default;

        /**
         * ImpactIonization constructor
         * @param model       Name of the impact ionization model
         * @param temperature Temperature for which the mobility model should be initialized
         */
        ImpactIonization(const std::string& model, double temperature) {
            if(model == "massey") {
                model_ = std::make_unique<Massey>(temperature);
            } else if(model == "overstraeten") {
                model_ = std::make_unique<VanOverstraeten>(temperature);
            } else if(model == "none") {
                LOG(INFO) << "No impact ionization model chosen, charge multiplication not simulated";
                model_ = std::make_unique<None>();
            } else {
                throw InvalidModelError(model);
            }
        }

        /**
         * Function call operator forwarded to the impact ionization model
         * @return Gain
         */
        template <class... ARGS> double operator()(ARGS&&... args) const {
            return model_->operator()(std::forward<ARGS>(args)...);
        }

    private:
        std::unique_ptr<ImpactIonizationModel> model_{};
    };

} // namespace allpix

#endif
